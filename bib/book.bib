@article{GHCInliner,
author = {Peyton Jones, Simon and Marlow, Simon},
title = {Secrets of the Glasgow Haskell Compiler Inliner},
year = {2002},
issue_date = {July 2002},
publisher = {Cambridge University Press},
address = {USA},
volume = {12},
number = {5},
issn = {0956-7968},
url = {https://doi.org/10.1017/S0956796802004331},
doi = {10.1017/S0956796802004331},
abstract = {Higher-order languages such as Haskell encourage the programmer to build abstractions by composing functions. A good compiler must inline many of these calls to recover an efficiently executable program. In principle, inlining is dead simple: just replace the call of a function by an instance of its body. But any compiler-writer will tell you that inlining is a black art, full of delicate compromises that work together to give good performance without unnecessary code bloat. The purpose of this paper is, therefore, to articulate the key lessons we learned from a full-scale “production” inliner, the one used in the Glasgow Haskell compiler. We focus mainly on the algorithmic aspects, but we also provide some indicative measurements to substantiate the importance of various aspects of the inliner.},
journal = {J. Funct. Program.},
month = {jul},
pages = {393–434},
numpages = {42}
}

@inproceedings{SpinelessTaglessGMachine,
author = {Peyton Jones, Simon L. and Salkild, Jon},
title = {The Spineless Tagless G-Machine},
year = {1989},
isbn = {0897913280},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/99370.99385},
doi = {10.1145/99370.99385},
booktitle = {Proceedings of the Fourth International Conference on Functional Programming Languages and Computer Architecture},
pages = {184–201},
numpages = {18},
location = {Imperial College, London, United Kingdom},
series = {FPCA '89}
}

@misc{partain1996let-floating,
author = {Partain, WD and Santos, A and Peyton Jones, Simon},
title = {Let-floating: moving bindings to give faster programs},
year = {1996},
month = {May},
abstract = {Virtually every compiler performs transformations on the program it
                  is compiling in an attempt to improve efficiency. Despite
                  their importance, however, there have been few systematic
                  attempts to categorise such transformations and measure their
                  impact. In this paper we describe a particular group of
                  transformations - the "let-floating" transformations - and
                  give detailed measurements of their effect in an optimising
                  compiler for the non-strict functional language Haskell.
                  Let-floating has not received much explicit attention in the
                  past, but our measurements show that it is an important group
                  of transformations (at least for lazy languages), offering a
                  reduction of more than 30% in heap allocation and 15% in
                  execution time.},
publisher = {ACM Press},
url = {https://www.microsoft.com/en-us/research/publication/let-floating-moving-bindings-to-give-faster-programs/},
edition = {ACM SIGPLAN International Conference on Functional Programming (ICFP'96)},
note = {ACM SIGPLAN International Conference on Functional Programming (ICFP'96)},
}

@article{peytonjones1997a,
author = {Peyton Jones, Simon and Santos, Andre},
title = {A transformation-based optimiser for Haskell},
year = {1997},
month = {October},
abstract = {Many compilers do some of their work by means of
                  correctness-preserving, and hopefully performance-improving,
                  program transformations. The Glasgow Haskell Compiler (GHC)
                  takes this idea of "compilation by transformation" as its
                  war-cry, trying to express as much as possible of the
                  compilation process in the form of program transformations.
                  This paper reports on our practical experience of the
                  transformational approach to compilation, in the context of a
                  substantial compiler. This is a journal version of
                  "Compilation by program transformation: a report from the
                  trenches" (ESOP'96)},
url = {https://www.microsoft.com/en-us/research/publication/a-transformation-based-optimiser-for-haskell/},
journal = {Science of Computer Programming},
volume = {32},
number = {1},
}
@inproceedings{10.1145/1640089.1640133,
author = {Cook, William R.},
title = {On Understanding Data Abstraction, Revisited},
year = {2009},
isbn = {9781605587660},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1640089.1640133},
doi = {10.1145/1640089.1640133},
abstract = {In 1985 Luca Cardelli and Peter Wegner, my advisor, published an ACM Computing Surveys paper called "On understanding types, data abstraction, and polymorphism". Their work kicked off a flood of research on semantics and type theory for object-oriented programming, which continues to this day. Despite 25 years of research, there is still widespread confusion about the two forms of data abstraction, abstract data types and objects. This essay attempts to explain the differences and also why the differences matter.},
booktitle = {Proceedings of the 24th ACM SIGPLAN Conference on Object Oriented Programming Systems Languages and Applications},
pages = {557–572},
numpages = {16},
keywords = {object, ADT, abstract data type, class},
location = {Orlando, Florida, USA},
series = {OOPSLA '09}
}

@article{dataAbstractionRevisited,
author = {Cook, William R.},
title = {On Understanding Data Abstraction, Revisited},
year = {2009},
issue_date = {October 2009},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {44},
number = {10},
issn = {0362-1340},
url = {https://doi.org/10.1145/1639949.1640133},
doi = {10.1145/1639949.1640133},
abstract = {In 1985 Luca Cardelli and Peter Wegner, my advisor, published an ACM Computing Surveys paper called "On understanding types, data abstraction, and polymorphism". Their work kicked off a flood of research on semantics and type theory for object-oriented programming, which continues to this day. Despite 25 years of research, there is still widespread confusion about the two forms of data abstraction, abstract data types and objects. This essay attempts to explain the differences and also why the differences matter.},
journal = {SIGPLAN Not.},
month = {oct},
pages = {557–572},
numpages = {16},
keywords = {object, class, abstract data type, ADT}
}
